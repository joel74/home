#!/usr/bin/env python

from __future__ import print_function

import argparse
import distutils.dir_util
import os.path
import sys
import yaml

class Platform(object):
    def __init__(self, os_family, dependencies=None, install_task=None):
        self.os_family     = os_family
        self.dependencies  = dependencies or []
        self.install_task  = install_task or (lambda pkg: None)

Platform.platforms = {
    'darwin': Platform(
        os_family    = 'Darwin',
        dependencies = [ 'darwin/homebrew' ],
        install_task = lambda pkg: {
            'name':     'install',
            'homebrew': 'name={0} state=latest'.format(pkg)
        }
    ),

    'freebsd': Platform(
        os_family    = 'FreeBSD',
        dependencies = [ 'freebsd/portsnap' ],
        install_task = lambda pkg: {
            'name': 'install',
            'sudo': 'yes',
            'port': 'name={0} state=present'.format(pkg)
        }
    )
}

class Role(object):
    def __init__(self, name):
        self.name = name
        self.path = os.path.join('roles', name)
        self.dependencies = []
        self.tasks = []
        self.meta = {}

    def add_dependency(self, dependency, when=None):
        if when is not None:
            dependency = {
                'role': dependency,
                'when': when
            }
        self.dependencies.append(dependency)

    def scaffold(self):
        if self.dependencies:
            self.meta['dependencies'] = self.dependencies

        self._mkyml(self.meta,  'meta')
        self._mkyml(self.tasks, 'tasks', empty=True)

    def _mkyml(self, contents, dirname, filename='main.yml', empty=False):
        if not empty and Role._is_empty(contents):
            return

        self._mkdir(dirname)
        path = os.path.join(self.path, dirname, filename)

        if os.path.isfile(path):
            print("already exists: {0}".format(path), file=sys.stderr)
            return

        print(path)

        with open(path, 'w') as f:
            if Role._is_empty(contents):
                f.write('---\n')
            else:
                yaml.dump(contents, f, explicit_start=True)

    def _mkdir(self, *args):
        path = os.path.join(self.path, *args)
        distutils.dir_util.mkpath(path)

    @staticmethod
    def _is_empty(obj):
        return obj is None or len(obj) == 0


def scaffold_role(args):
    role = Role(args.name)
    role.scaffold()

def scaffold_pkg(args):
    pkg_role = Role(args.name)

    for plat_name, plat in Platform.platforms.iteritems():
        plat_role = Role('{0}/{1}'.format(pkg_role.name, plat_name))

        pkg_role.add_dependency(
            plat_role.name,
            when='ansible_os_family == "{0}"'.format(plat.os_family)
        )

        plat_role.dependencies = plat.dependencies
        plat_role.scaffold()

    pkg_role.scaffold()

def scaffold_platform_pkg(args):
    pass

parser     = argparse.ArgumentParser()
subparsers = parser.add_subparsers(title='subcommands')

role_parser = subparsers.add_parser('role', help='Scaffolds an empty role')
role_parser.add_argument('name', metavar='name')
role_parser.set_defaults(func=scaffold_role)

pkg_parser = subparsers.add_parser('pkg', help='Scaffolds a package-installing role with platform-specific subroles.')
pkg_parser.add_argument('name', metavar='name')
pkg_parser.set_defaults(func=scaffold_pkg)

args = parser.parse_args()
args.func(args)
