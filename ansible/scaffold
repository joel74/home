#!/usr/bin/env python

from __future__ import print_function

import argparse
import distutils.dir_util
import itertools
import os.path
import re
import subprocess
import sys
import yaml

def stderr(message):
    print(message, file=sys.stderr)

class Platform(object):
    def __init__(self, os_family, role_name):
        self.os_family = os_family
        self.name      = os_family.lower()
        self.role_name = role_name

    @classmethod
    def get(cls, name):
        return next((p for p in cls.all() if p.name == name), None)

    @classmethod
    def all(cls):
        return [ p for p in vars(cls).values() if isinstance(p, cls) ]

Platform.DARWIN  = Platform('Darwin',  'brew')
Platform.FREEBSD = Platform('FreeBSD', 'port')

class Role(object):
    PREFIX = 'roles'

    def __init__(self, name_or_path):
        self.name = Role.strip_prefix(name_or_path)
        self.path = Role.prepend_prefix(self.name)

        self.defaults     = {}
        self.dependencies = []
        self.meta         = {}
        self.tasks        = []

        self.empty_defaults = False
        self.empty_tasks = False
        self.empty_meta = False

    def add_dependency(self, dependency=None, **kwargs):
        self.dependencies.append(dependency or kwargs)

    def scaffold(self):
        if self.dependencies:
            self.meta['dependencies'] = self.dependencies

        self._mkyml(self.defaults, 'defaults', empty=self.empty_defaults)
        self._mkyml(self.meta,     'meta',     empty=self.empty_meta)
        self._mkyml(self.tasks,    'tasks',    empty=self.empty_tasks)

    @property
    def files(self):
        for root, _, filenames in os.walk(self.path):
            for fn in filenames:
                yield os.path.join(root, fn)

    def _mkyml(self, contents, dirname, filename='main.yml', empty=False):
        if not empty and Role._is_empty(contents):
            return

        self._mkdir(dirname)
        path = os.path.join(self.path, dirname, filename)

        if os.path.isfile(path):
            stderr("already exists: {0}".format(path))
            return

        print(path)

        with open(path, 'w') as f:
            if Role._is_empty(contents):
                f.write('---\n')
            else:
                yaml.dump(contents, f, explicit_start=True)

    def _mkdir(self, *args):
        path = os.path.join(self.path, *args)
        distutils.dir_util.mkpath(path)

    @staticmethod
    def strip_prefix(path, prefix = PREFIX):
        prefix = re.escape(prefix)
        expr   = '^{0}/(.*)$'.format(prefix)

        m = re.match(expr, path)

        if m:
            path = m.group(1)

        return path

    @staticmethod
    def prepend_prefix(name, prefix = PREFIX):
        return os.path.join(prefix, name)

    @staticmethod
    def _is_empty(obj):
        return obj is None or len(obj) == 0


class ScaffolderCommand(object):

    def parser(self, sp):
        pass

    def scaffold(self, args):
        raise NotImplementedError("Scaffolder.scaffold not implemented!")

    def run(self, args):
        for r in self.scaffold(args):
            r.scaffold()

    def add_name_argument(self, p):
        p.add_argument(
                'name',
                metavar=' name'
            )

    @classmethod
    def main(cls):
        parser = argparse.ArgumentParser()
        subparsers = parser.add_subparsers(
                title='subcommands'
            )

        for subclass in cls.__subclasses__():
            sp = subparsers.add_parser(
                    subclass.COMMAND,
                    help=(subclass.__doc__)
                )

            inst = subclass()
            inst.parser(sp)
            sp.set_defaults(func=inst.run)

        args = parser.parse_args()
        args.func(args)

class RoleScaffolder(ScaffolderCommand):
    """
    Scaffolds an empty role.
    """

    COMMAND = 'role'

    def parser(self, sp):
        self.add_name_argument(sp)
        sp.add_argument('--defaults', action='store_true')

    def scaffold(self, args):
        role = Role(args.name)
        role.empty_tasks = True
        role.empty_defaults = args.defaults
        yield role

class PackageScaffolder(ScaffolderCommand):
    """
    Scaffolds a platform independent role with dependencies
    on platform-specific roles.
    """

    COMMAND = 'pkg'

    def parser(self, sp):
        self.add_name_argument(sp)

    def scaffold(self, args):
        pkg_role = Role(args.name)

        for plat in Platform.all():
            plat_role = Role(
                    os.path.join(plat.name, plat.role_name, pkg_role.name)
                )

            plat_role.add_dependency(
                    role = os.path.join(plat.name, plat.role_name),
                    name = pkg_role.name
                )

            pkg_role.add_dependency(
                    role = plat_role.name,
                    when = 'ansible_os_family == "{0}"'.format(plat.os_family)
                )

            yield plat_role

        yield pkg_role

#class PlatformPackageScaffolder(ScaffolderCommand):
#    """Scaffolds a platform-specific package role."""
#
#    COMMAND = 'platform-pkg'
#
#    def parser(self, sp):
#        sp.add_argument('-p', '--platform',
#                metavar='platform-name',
#                choices=map(lambda p: p.name, Platform.all())
#            )
#        sp.add_argument('name', metavar='package-name')
#
#    def scaffold(self, args):
#        name = Role.strip_prefix(args.name)
#        platform = None
#
#        if args.platform:
#            platform = Platform.get(args.platform)
#
#        if platform is None:
#            parts    = name.split('/')
#            name     = os.path.join(*parts[1:])
#            platform = Platform.get(parts[0])
#
#            if platform is None:
#                stderr("platform must be specified either using the -p parameter, " +
#                       "or as the first part of the role name")
#                return
#
#        path = os.path.join(platform.name, name)
#        yield PlatformPkgRole(path, name, platform)

class RoleEditor(ScaffolderCommand):
    """
    Open all role files in a text editor.
    """

    COMMAND = 'edit'

    def parser(self, p):
        p.add_argument('name', nargs='+')

    def run(self, args):
        command = [ os.getenv('EDITOR') or
                    os.getenv('VISUAL') or
                    'vi' ]

        roles = map(Role, args.name)

        paths    = list(itertools.chain.from_iterable(r.files for r in roles))
        root     = RoleEditor._common_path(paths)
        relpaths = [ os.path.relpath(p, start=root) for p in paths ]

        command.extend(relpaths)
        subprocess.call(command, cwd=root)

    @staticmethod
    def _common_path(paths):
        def allequal(lst):
            return all(i == lst[0] for i in lst[1:])

        paths        = map(os.path.normpath, paths)
        by_dir_level = zip(*[p.split(os.path.sep) for p in paths])
        common       = list(itertools.takewhile(allequal, by_dir_level))

        return os.path.sep.join(zip(*common)[0])

ScaffolderCommand.main()
